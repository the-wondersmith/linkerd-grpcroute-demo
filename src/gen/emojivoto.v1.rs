// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Emoji {
    #[prost(string, tag = "1")]
    pub unicode: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub shortcode: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllEmojiRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllEmojiResponse {
    #[prost(message, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<Emoji>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindByShortcodeRequest {
    #[prost(string, tag = "1")]
    pub shortcode: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindByShortcodeResponse {
    #[prost(message, optional, tag = "1")]
    pub emoji: ::core::option::Option<Emoji>,
}
/// Generated client implementations.
pub mod emoji_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct EmojiServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EmojiServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EmojiServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EmojiServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            EmojiServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn list_all(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAllEmojiRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAllEmojiResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.EmojiService/ListAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.EmojiService", "ListAll"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn find_by_shortcode(
            &mut self,
            request: impl tonic::IntoRequest<super::FindByShortcodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindByShortcodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.EmojiService/FindByShortcode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.EmojiService", "FindByShortcode"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod emoji_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with EmojiServiceServer.
    #[async_trait]
    pub trait EmojiService: Send + Sync + 'static {
        async fn list_all(
            &self,
            request: tonic::Request<super::ListAllEmojiRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAllEmojiResponse>,
            tonic::Status,
        >;
        async fn find_by_shortcode(
            &self,
            request: tonic::Request<super::FindByShortcodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FindByShortcodeResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct EmojiServiceServer<T: EmojiService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: EmojiService> EmojiServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for EmojiServiceServer<T>
    where
        T: EmojiService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/emojivoto.v1.EmojiService/ListAll" => {
                    #[allow(non_camel_case_types)]
                    struct ListAllSvc<T: EmojiService>(pub Arc<T>);
                    impl<
                        T: EmojiService,
                    > tonic::server::UnaryService<super::ListAllEmojiRequest>
                    for ListAllSvc<T> {
                        type Response = super::ListAllEmojiResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListAllEmojiRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as EmojiService>::list_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ListAllSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.EmojiService/FindByShortcode" => {
                    #[allow(non_camel_case_types)]
                    struct FindByShortcodeSvc<T: EmojiService>(pub Arc<T>);
                    impl<
                        T: EmojiService,
                    > tonic::server::UnaryService<super::FindByShortcodeRequest>
                    for FindByShortcodeSvc<T> {
                        type Response = super::FindByShortcodeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FindByShortcodeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as EmojiService>::find_by_shortcode(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = FindByShortcodeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: EmojiService> Clone for EmojiServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: EmojiService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: EmojiService> tonic::server::NamedService for EmojiServiceServer<T> {
        const NAME: &'static str = "emojivoto.v1.EmojiService";
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VotingResult {
    #[prost(string, tag = "1")]
    pub shortcode: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub votes: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoteRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoteResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResultsRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResultsResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<VotingResult>,
}
/// Generated client implementations.
pub mod voting_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct VotingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl VotingServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> VotingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VotingServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            VotingServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn vote_poop(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePoop",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePoop"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_joy(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteJoy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteJoy"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_sunglasses(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSunglasses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteSunglasses"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_relaxed(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteRelaxed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteRelaxed"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_stuck_out_tongue_winking_eye(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteStuckOutTongueWinkingEye",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "emojivoto.v1.VotingService",
                        "VoteStuckOutTongueWinkingEye",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_money_mouth_face(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteMoneyMouthFace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteMoneyMouthFace"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_flushed(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteFlushed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteFlushed"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_mask(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteMask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteMask"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_nerd_face(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteNerdFace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteNerdFace"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_ghost(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteGhost",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteGhost"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_skull_and_crossbones(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSkullAndCrossbones",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "emojivoto.v1.VotingService",
                        "VoteSkullAndCrossbones",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_heart_eyes_cat(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteHeartEyesCat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteHeartEyesCat"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_hear_no_evil(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteHearNoEvil",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteHearNoEvil"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_see_no_evil(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSeeNoEvil",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteSeeNoEvil"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_speak_no_evil(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSpeakNoEvil",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteSpeakNoEvil"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_boy(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBoy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteBoy"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_girl(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteGirl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteGirl"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteMan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_woman(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteWoman",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteWoman"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_older_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteOlderMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteOlderMan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_policeman(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePoliceman",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePoliceman"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_guardsman(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteGuardsman",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteGuardsman"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_construction_worker_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteConstructionWorkerMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "emojivoto.v1.VotingService",
                        "VoteConstructionWorkerMan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_prince(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePrince",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePrince"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_princess(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePrincess",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePrincess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_man_in_tuxedo(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteManInTuxedo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteManInTuxedo"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_bride_with_veil(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBrideWithVeil",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteBrideWithVeil"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_mrs_claus(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteMrsClaus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteMrsClaus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_santa(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSanta",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteSanta"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_turkey(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteTurkey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteTurkey"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_rabbit(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteRabbit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteRabbit"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_no_good_woman(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteNoGoodWoman",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteNoGoodWoman"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_ok_woman(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteOkWoman",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteOkWoman"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_raising_hand_woman(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteRaisingHandWoman",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteRaisingHandWoman"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_bowing_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBowingMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteBowingMan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_man_facepalming(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteManFacepalming",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteManFacepalming"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_woman_shrugging(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteWomanShrugging",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteWomanShrugging"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_massage_woman(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteMassageWoman",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteMassageWoman"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_walking_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteWalkingMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteWalkingMan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_running_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteRunningMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteRunningMan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_dancer(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteDancer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteDancer"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_man_dancing(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteManDancing",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteManDancing"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_dancing_women(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteDancingWomen",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteDancingWomen"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_rainbow(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteRainbow",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteRainbow"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_skier(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSkier",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteSkier"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_golfing_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteGolfingMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteGolfingMan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_surfing_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSurfingMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteSurfingMan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_basketball_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBasketballMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteBasketballMan"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_biking_man(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBikingMan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteBikingMan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_point_up2(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePointUp2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePointUp2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_vulcan_salute(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteVulcanSalute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteVulcanSalute"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_metal(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteMetal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteMetal"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_call_me_hand(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteCallMeHand",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteCallMeHand"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_thumbsup(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteThumbsup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteThumbsup"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_wave(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteWave",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteWave"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_clap(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteClap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteClap"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_raised_hands(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteRaisedHands",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteRaisedHands"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_pray(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePray",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePray"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_dog(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteDog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteDog"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_cat2(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteCat2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteCat2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_pig(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePig"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_hatching_chick(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteHatchingChick",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteHatchingChick"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_snail(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSnail",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteSnail"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_bacon(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBacon",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteBacon"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_pizza(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePizza",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePizza"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_taco(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteTaco",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteTaco"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_burrito(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBurrito",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteBurrito"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_ramen(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteRamen",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteRamen"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_doughnut(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteDoughnut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteDoughnut"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_champagne(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteChampagne",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteChampagne"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_tropical_drink(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteTropicalDrink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteTropicalDrink"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_beer(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBeer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteBeer"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_tumbler_glass(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteTumblerGlass",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteTumblerGlass"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_world_map(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteWorldMap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteWorldMap"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_beach_umbrella(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBeachUmbrella",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteBeachUmbrella"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_mountain_snow(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteMountainSnow",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteMountainSnow"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_camping(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteCamping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteCamping"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_steam_locomotive(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSteamLocomotive",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteSteamLocomotive"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_flight_departure(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteFlightDeparture",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteFlightDeparture"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_rocket(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteRocket",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteRocket"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_star2(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteStar2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteStar2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_sun_behind_small_cloud(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteSunBehindSmallCloud",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "emojivoto.v1.VotingService",
                        "VoteSunBehindSmallCloud",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_cloud_with_rain(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteCloudWithRain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteCloudWithRain"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_fire(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteFire",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteFire"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_jack_o_lantern(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteJackOLantern",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteJackOLantern"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_balloon(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBalloon",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteBalloon"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_tada(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteTada",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteTada"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_trophy(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteTrophy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteTrophy"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_iphone(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteIphone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteIphone"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_pager(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VotePager",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VotePager"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_fax(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteFax",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteFax"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_bulb(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteBulb",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteBulb"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_money_with_wings(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteMoneyWithWings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteMoneyWithWings"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_crystal_ball(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteCrystalBall",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteCrystalBall"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_underage(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteUnderage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteUnderage"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_interrobang(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteInterrobang",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteInterrobang"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote100(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/Vote100",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "Vote100"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_checkered_flag(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteCheckeredFlag",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteCheckeredFlag"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_crossed_swords(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteCrossedSwords",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("emojivoto.v1.VotingService", "VoteCrossedSwords"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn vote_floppy_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/VoteFloppyDisk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "VoteFloppyDisk"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn results(
            &mut self,
            request: impl tonic::IntoRequest<super::ResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/emojivoto.v1.VotingService/Results",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("emojivoto.v1.VotingService", "Results"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod voting_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with VotingServiceServer.
    #[async_trait]
    pub trait VotingService: Send + Sync + 'static {
        async fn vote_poop(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_joy(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_sunglasses(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_relaxed(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_stuck_out_tongue_winking_eye(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_money_mouth_face(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_flushed(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_mask(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_nerd_face(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_ghost(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_skull_and_crossbones(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_heart_eyes_cat(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_hear_no_evil(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_see_no_evil(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_speak_no_evil(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_boy(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_girl(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_woman(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_older_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_policeman(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_guardsman(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_construction_worker_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_prince(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_princess(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_man_in_tuxedo(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_bride_with_veil(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_mrs_claus(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_santa(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_turkey(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_rabbit(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_no_good_woman(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_ok_woman(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_raising_hand_woman(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_bowing_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_man_facepalming(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_woman_shrugging(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_massage_woman(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_walking_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_running_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_dancer(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_man_dancing(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_dancing_women(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_rainbow(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_skier(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_golfing_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_surfing_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_basketball_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_biking_man(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_point_up2(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_vulcan_salute(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_metal(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_call_me_hand(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_thumbsup(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_wave(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_clap(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_raised_hands(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_pray(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_dog(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_cat2(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_pig(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_hatching_chick(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_snail(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_bacon(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_pizza(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_taco(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_burrito(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_ramen(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_doughnut(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_champagne(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_tropical_drink(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_beer(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_tumbler_glass(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_world_map(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_beach_umbrella(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_mountain_snow(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_camping(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_steam_locomotive(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_flight_departure(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_rocket(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_star2(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_sun_behind_small_cloud(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_cloud_with_rain(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_fire(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_jack_o_lantern(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_balloon(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_tada(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_trophy(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_iphone(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_pager(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_fax(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_bulb(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_money_with_wings(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_crystal_ball(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_underage(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_interrobang(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote100(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_checkered_flag(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_crossed_swords(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn vote_floppy_disk(
            &self,
            request: tonic::Request<super::VoteRequest>,
        ) -> std::result::Result<tonic::Response<super::VoteResponse>, tonic::Status>;
        async fn results(
            &self,
            request: tonic::Request<super::ResultsRequest>,
        ) -> std::result::Result<tonic::Response<super::ResultsResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct VotingServiceServer<T: VotingService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: VotingService> VotingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for VotingServiceServer<T>
    where
        T: VotingService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/emojivoto.v1.VotingService/VotePoop" => {
                    #[allow(non_camel_case_types)]
                    struct VotePoopSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VotePoopSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_poop(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePoopSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteJoy" => {
                    #[allow(non_camel_case_types)]
                    struct VoteJoySvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest> for VoteJoySvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_joy(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteJoySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSunglasses" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSunglassesSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSunglassesSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_sunglasses(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSunglassesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteRelaxed" => {
                    #[allow(non_camel_case_types)]
                    struct VoteRelaxedSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteRelaxedSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_relaxed(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteRelaxedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteStuckOutTongueWinkingEye" => {
                    #[allow(non_camel_case_types)]
                    struct VoteStuckOutTongueWinkingEyeSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteStuckOutTongueWinkingEyeSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_stuck_out_tongue_winking_eye(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteStuckOutTongueWinkingEyeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteMoneyMouthFace" => {
                    #[allow(non_camel_case_types)]
                    struct VoteMoneyMouthFaceSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteMoneyMouthFaceSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_money_mouth_face(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteMoneyMouthFaceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteFlushed" => {
                    #[allow(non_camel_case_types)]
                    struct VoteFlushedSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteFlushedSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_flushed(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteFlushedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteMask" => {
                    #[allow(non_camel_case_types)]
                    struct VoteMaskSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteMaskSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_mask(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteMaskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteNerdFace" => {
                    #[allow(non_camel_case_types)]
                    struct VoteNerdFaceSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteNerdFaceSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_nerd_face(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteNerdFaceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteGhost" => {
                    #[allow(non_camel_case_types)]
                    struct VoteGhostSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteGhostSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_ghost(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteGhostSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSkullAndCrossbones" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSkullAndCrossbonesSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSkullAndCrossbonesSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_skull_and_crossbones(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSkullAndCrossbonesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteHeartEyesCat" => {
                    #[allow(non_camel_case_types)]
                    struct VoteHeartEyesCatSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteHeartEyesCatSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_heart_eyes_cat(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteHeartEyesCatSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteHearNoEvil" => {
                    #[allow(non_camel_case_types)]
                    struct VoteHearNoEvilSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteHearNoEvilSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_hear_no_evil(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteHearNoEvilSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSeeNoEvil" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSeeNoEvilSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSeeNoEvilSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_see_no_evil(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSeeNoEvilSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSpeakNoEvil" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSpeakNoEvilSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSpeakNoEvilSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_speak_no_evil(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSpeakNoEvilSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBoy" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBoySvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest> for VoteBoySvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_boy(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBoySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteGirl" => {
                    #[allow(non_camel_case_types)]
                    struct VoteGirlSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteGirlSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_girl(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteGirlSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest> for VoteManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_man(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteWoman" => {
                    #[allow(non_camel_case_types)]
                    struct VoteWomanSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteWomanSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_woman(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteWomanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteOlderMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteOlderManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteOlderManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_older_man(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteOlderManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VotePoliceman" => {
                    #[allow(non_camel_case_types)]
                    struct VotePolicemanSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VotePolicemanSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_policeman(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePolicemanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteGuardsman" => {
                    #[allow(non_camel_case_types)]
                    struct VoteGuardsmanSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteGuardsmanSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_guardsman(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteGuardsmanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteConstructionWorkerMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteConstructionWorkerManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteConstructionWorkerManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_construction_worker_man(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteConstructionWorkerManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VotePrince" => {
                    #[allow(non_camel_case_types)]
                    struct VotePrinceSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VotePrinceSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_prince(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePrinceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VotePrincess" => {
                    #[allow(non_camel_case_types)]
                    struct VotePrincessSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VotePrincessSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_princess(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePrincessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteManInTuxedo" => {
                    #[allow(non_camel_case_types)]
                    struct VoteManInTuxedoSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteManInTuxedoSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_man_in_tuxedo(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteManInTuxedoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBrideWithVeil" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBrideWithVeilSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBrideWithVeilSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_bride_with_veil(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBrideWithVeilSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteMrsClaus" => {
                    #[allow(non_camel_case_types)]
                    struct VoteMrsClausSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteMrsClausSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_mrs_claus(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteMrsClausSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSanta" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSantaSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSantaSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_santa(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSantaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteTurkey" => {
                    #[allow(non_camel_case_types)]
                    struct VoteTurkeySvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteTurkeySvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_turkey(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteTurkeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteRabbit" => {
                    #[allow(non_camel_case_types)]
                    struct VoteRabbitSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteRabbitSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_rabbit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteRabbitSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteNoGoodWoman" => {
                    #[allow(non_camel_case_types)]
                    struct VoteNoGoodWomanSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteNoGoodWomanSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_no_good_woman(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteNoGoodWomanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteOkWoman" => {
                    #[allow(non_camel_case_types)]
                    struct VoteOkWomanSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteOkWomanSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_ok_woman(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteOkWomanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteRaisingHandWoman" => {
                    #[allow(non_camel_case_types)]
                    struct VoteRaisingHandWomanSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteRaisingHandWomanSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_raising_hand_woman(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteRaisingHandWomanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBowingMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBowingManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBowingManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_bowing_man(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBowingManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteManFacepalming" => {
                    #[allow(non_camel_case_types)]
                    struct VoteManFacepalmingSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteManFacepalmingSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_man_facepalming(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteManFacepalmingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteWomanShrugging" => {
                    #[allow(non_camel_case_types)]
                    struct VoteWomanShruggingSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteWomanShruggingSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_woman_shrugging(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteWomanShruggingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteMassageWoman" => {
                    #[allow(non_camel_case_types)]
                    struct VoteMassageWomanSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteMassageWomanSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_massage_woman(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteMassageWomanSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteWalkingMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteWalkingManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteWalkingManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_walking_man(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteWalkingManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteRunningMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteRunningManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteRunningManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_running_man(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteRunningManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteDancer" => {
                    #[allow(non_camel_case_types)]
                    struct VoteDancerSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteDancerSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_dancer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteDancerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteManDancing" => {
                    #[allow(non_camel_case_types)]
                    struct VoteManDancingSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteManDancingSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_man_dancing(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteManDancingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteDancingWomen" => {
                    #[allow(non_camel_case_types)]
                    struct VoteDancingWomenSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteDancingWomenSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_dancing_women(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteDancingWomenSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteRainbow" => {
                    #[allow(non_camel_case_types)]
                    struct VoteRainbowSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteRainbowSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_rainbow(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteRainbowSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSkier" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSkierSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSkierSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_skier(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSkierSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteGolfingMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteGolfingManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteGolfingManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_golfing_man(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteGolfingManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSurfingMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSurfingManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSurfingManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_surfing_man(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSurfingManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBasketballMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBasketballManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBasketballManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_basketball_man(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBasketballManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBikingMan" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBikingManSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBikingManSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_biking_man(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBikingManSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VotePointUp2" => {
                    #[allow(non_camel_case_types)]
                    struct VotePointUp2Svc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VotePointUp2Svc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_point_up2(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePointUp2Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteVulcanSalute" => {
                    #[allow(non_camel_case_types)]
                    struct VoteVulcanSaluteSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteVulcanSaluteSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_vulcan_salute(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteVulcanSaluteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteMetal" => {
                    #[allow(non_camel_case_types)]
                    struct VoteMetalSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteMetalSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_metal(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteMetalSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteCallMeHand" => {
                    #[allow(non_camel_case_types)]
                    struct VoteCallMeHandSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteCallMeHandSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_call_me_hand(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteCallMeHandSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteThumbsup" => {
                    #[allow(non_camel_case_types)]
                    struct VoteThumbsupSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteThumbsupSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_thumbsup(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteThumbsupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteWave" => {
                    #[allow(non_camel_case_types)]
                    struct VoteWaveSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteWaveSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_wave(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteWaveSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteClap" => {
                    #[allow(non_camel_case_types)]
                    struct VoteClapSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteClapSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_clap(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteClapSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteRaisedHands" => {
                    #[allow(non_camel_case_types)]
                    struct VoteRaisedHandsSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteRaisedHandsSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_raised_hands(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteRaisedHandsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VotePray" => {
                    #[allow(non_camel_case_types)]
                    struct VotePraySvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VotePraySvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_pray(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePraySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteDog" => {
                    #[allow(non_camel_case_types)]
                    struct VoteDogSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest> for VoteDogSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_dog(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteDogSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteCat2" => {
                    #[allow(non_camel_case_types)]
                    struct VoteCat2Svc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteCat2Svc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_cat2(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteCat2Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VotePig" => {
                    #[allow(non_camel_case_types)]
                    struct VotePigSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest> for VotePigSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_pig(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteHatchingChick" => {
                    #[allow(non_camel_case_types)]
                    struct VoteHatchingChickSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteHatchingChickSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_hatching_chick(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteHatchingChickSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSnail" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSnailSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSnailSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_snail(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSnailSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBacon" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBaconSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBaconSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_bacon(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBaconSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VotePizza" => {
                    #[allow(non_camel_case_types)]
                    struct VotePizzaSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VotePizzaSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_pizza(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePizzaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteTaco" => {
                    #[allow(non_camel_case_types)]
                    struct VoteTacoSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteTacoSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_taco(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteTacoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBurrito" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBurritoSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBurritoSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_burrito(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBurritoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteRamen" => {
                    #[allow(non_camel_case_types)]
                    struct VoteRamenSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteRamenSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_ramen(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteRamenSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteDoughnut" => {
                    #[allow(non_camel_case_types)]
                    struct VoteDoughnutSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteDoughnutSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_doughnut(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteDoughnutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteChampagne" => {
                    #[allow(non_camel_case_types)]
                    struct VoteChampagneSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteChampagneSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_champagne(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteChampagneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteTropicalDrink" => {
                    #[allow(non_camel_case_types)]
                    struct VoteTropicalDrinkSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteTropicalDrinkSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_tropical_drink(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteTropicalDrinkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBeer" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBeerSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBeerSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_beer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBeerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteTumblerGlass" => {
                    #[allow(non_camel_case_types)]
                    struct VoteTumblerGlassSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteTumblerGlassSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_tumbler_glass(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteTumblerGlassSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteWorldMap" => {
                    #[allow(non_camel_case_types)]
                    struct VoteWorldMapSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteWorldMapSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_world_map(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteWorldMapSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBeachUmbrella" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBeachUmbrellaSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBeachUmbrellaSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_beach_umbrella(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBeachUmbrellaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteMountainSnow" => {
                    #[allow(non_camel_case_types)]
                    struct VoteMountainSnowSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteMountainSnowSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_mountain_snow(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteMountainSnowSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteCamping" => {
                    #[allow(non_camel_case_types)]
                    struct VoteCampingSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteCampingSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_camping(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteCampingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSteamLocomotive" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSteamLocomotiveSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSteamLocomotiveSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_steam_locomotive(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSteamLocomotiveSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteFlightDeparture" => {
                    #[allow(non_camel_case_types)]
                    struct VoteFlightDepartureSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteFlightDepartureSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_flight_departure(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteFlightDepartureSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteRocket" => {
                    #[allow(non_camel_case_types)]
                    struct VoteRocketSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteRocketSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_rocket(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteRocketSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteStar2" => {
                    #[allow(non_camel_case_types)]
                    struct VoteStar2Svc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteStar2Svc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_star2(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteStar2Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteSunBehindSmallCloud" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSunBehindSmallCloudSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteSunBehindSmallCloudSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_sun_behind_small_cloud(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteSunBehindSmallCloudSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteCloudWithRain" => {
                    #[allow(non_camel_case_types)]
                    struct VoteCloudWithRainSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteCloudWithRainSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_cloud_with_rain(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteCloudWithRainSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteFire" => {
                    #[allow(non_camel_case_types)]
                    struct VoteFireSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteFireSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_fire(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteFireSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteJackOLantern" => {
                    #[allow(non_camel_case_types)]
                    struct VoteJackOLanternSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteJackOLanternSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_jack_o_lantern(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteJackOLanternSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBalloon" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBalloonSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBalloonSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_balloon(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBalloonSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteTada" => {
                    #[allow(non_camel_case_types)]
                    struct VoteTadaSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteTadaSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_tada(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteTadaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteTrophy" => {
                    #[allow(non_camel_case_types)]
                    struct VoteTrophySvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteTrophySvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_trophy(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteTrophySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteIphone" => {
                    #[allow(non_camel_case_types)]
                    struct VoteIphoneSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteIphoneSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_iphone(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteIphoneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VotePager" => {
                    #[allow(non_camel_case_types)]
                    struct VotePagerSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VotePagerSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_pager(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VotePagerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteFax" => {
                    #[allow(non_camel_case_types)]
                    struct VoteFaxSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest> for VoteFaxSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_fax(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteFaxSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteBulb" => {
                    #[allow(non_camel_case_types)]
                    struct VoteBulbSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteBulbSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_bulb(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteBulbSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteMoneyWithWings" => {
                    #[allow(non_camel_case_types)]
                    struct VoteMoneyWithWingsSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteMoneyWithWingsSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_money_with_wings(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteMoneyWithWingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteCrystalBall" => {
                    #[allow(non_camel_case_types)]
                    struct VoteCrystalBallSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteCrystalBallSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_crystal_ball(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteCrystalBallSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteUnderage" => {
                    #[allow(non_camel_case_types)]
                    struct VoteUnderageSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteUnderageSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_underage(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteUnderageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteInterrobang" => {
                    #[allow(non_camel_case_types)]
                    struct VoteInterrobangSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteInterrobangSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_interrobang(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteInterrobangSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/Vote100" => {
                    #[allow(non_camel_case_types)]
                    struct Vote100Svc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest> for Vote100Svc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote100(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = Vote100Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteCheckeredFlag" => {
                    #[allow(non_camel_case_types)]
                    struct VoteCheckeredFlagSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteCheckeredFlagSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_checkered_flag(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteCheckeredFlagSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteCrossedSwords" => {
                    #[allow(non_camel_case_types)]
                    struct VoteCrossedSwordsSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteCrossedSwordsSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_crossed_swords(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteCrossedSwordsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/VoteFloppyDisk" => {
                    #[allow(non_camel_case_types)]
                    struct VoteFloppyDiskSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::VoteRequest>
                    for VoteFloppyDiskSvc<T> {
                        type Response = super::VoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::vote_floppy_disk(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = VoteFloppyDiskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/emojivoto.v1.VotingService/Results" => {
                    #[allow(non_camel_case_types)]
                    struct ResultsSvc<T: VotingService>(pub Arc<T>);
                    impl<
                        T: VotingService,
                    > tonic::server::UnaryService<super::ResultsRequest>
                    for ResultsSvc<T> {
                        type Response = super::ResultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as VotingService>::results(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ResultsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: VotingService> Clone for VotingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: VotingService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: VotingService> tonic::server::NamedService for VotingServiceServer<T> {
        const NAME: &'static str = "emojivoto.v1.VotingService";
    }
}
